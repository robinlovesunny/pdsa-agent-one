# Quest Mode

## 概述

Quest Mode 是一项 AI 辅助的编程功能，专为复杂、长时运行的开发任务而设计。你只需用自然语言描述需求，便可将功能开发、缺陷修复、重构与测试等任务交给 AI 执行，从而大幅提升开发效率。

Quest Mode 现已支持本地和远程两种执行模式，可以根据场景选择最符合你需求的选项。

## 关键特性

### AI 辅助规格说明（Specs）

AI 助手会分析你的项目并自动生成详细的技术设计文档（Spec）。这可确保对任务形成共同理解，并使 AI 的执行与你的目标保持一致。

### 自主执行

当 Spec 完成或你的需求已澄清后，AI 可开始异步执行任务。你可以通过 操作轨迹 视图实时监控进度，该视图展示执行计划、正在进行的操作以及遇到的任何问题。

### AI 辅助任务报告

完成后，AI 会生成任务报告，总结变更、测试结果和验证结论。这有助于你在决定接受或完善结果之前，快速评估工作的质量与完整性。

### 远程委派

在最终确定 Spec 设计后，你可以按需选择在本地或云端委派执行。我们推荐使用云端执行，可以获得更佳体验，包括融合智能调度、安全沙箱与IDE原生体验等。

## 如何创建任务

1. 点击 新建任务。
2. 选择相关的上下文（如项目文件或代码片段），并用自然语言输入任务描述。

### 选择工作流

- **设计并执行**： 在执行前先定义任务规范。适用于复杂改动。
- **直接执行**： 立即执行命令。适用于简单、快速的任务。

### 选择执行环境

#### 本地模式： Local

在本机直接运行任务，使用 git worktree 自动隔离代码变更并防止并发操作产生冲突。适合快速测试和即时反馈。所有文件修改都会应用到你当前的项目。

**提示**： 建议在 Settings > Quest Mode 中配置启动脚本，以便每当 Qoder 创建新的 worktree 时初始化目录。适用于安装依赖和设置环境，确保每个任务都在一致且可直接运行的状态下启动。

#### 远程模式

将任务委派到强大的云端环境。适合长时或资源密集型作业，使本机保持空闲并在沙盒中更安全。更改会自动同步回 IDE。

**依赖**： 远程模式需要已配置的 Git 仓库。请先在 Settings > Quest 模式 中完成设置再继续。目前仅官方支持 GitHub。

3. 点击 发送 或按 Enter 开始。AI 将根据你的输入开始起草详细的 Spec，或直接执行。

## 技术设计

在设计阶段，AI 会：

- 审阅你项目的记忆和工程上下文
- 分析代码库的结构
- 生成一份完整的 Spec 文档

生成 Spec 后，你可以自行编辑，或与 AI 一起打磨。它会自动保存到你项目中的 .qoder/quest 目录。

当你对 Spec 感到满意时，点击右上角的 开始任务 开始执行。

## 操作流程

任务开始后，你将进入操作流程视图，其中展示：

- AI 的执行计划
- 实时输出和日志
- 进度状态及任何阻塞项

对于简单任务，AI 可能会跳过生成详细计划，直接执行实现。

你可以随时添加新需求——即使任务正在运行——只需在聊天框中发送消息。AI 会相应调整计划并继续工作。

## 任务报告

当任务完成后，系统会切换到任务报告视图。AI 会提供结构化摘要，包括：

- 已完成的代码更改的总结
- 测试结果与验证结论
- 变更文件的详细列表

你可以分别查看每个代码文件的变更，并可以进行以下操作：

### 本地模式

- **接收**：点击 接收 将所有建议的更改应用到本地文件，并归档该任务。
- **废弃**：点击 废弃 撤销所有更改，将文件恢复到任务运行前的状态。
- **结束**：点击 结束 在不应用任何更改的情况下关闭任务。若未修改代码，优先使用此选项。

### 远程模式

- **检出到本地**：点击 检出到本地 将远程分支拉取到本机，以便进一步审查、本地测试或追加编辑。
- **创建 PR**：点击 创建 PR 在你的 Git 平台上创建一个 pull request，启动正式的代码评审与合并流程。
- **结束**：点击 结束 关闭任务。此操作不具破坏性；远程分支和已创建的 pull request 都会被保留。

如果需要继续处理，返回到 **操作轨迹** 视图，发送新消息，AI 将从上次中断处接着执行。

# 用户指南

## Repo Wiki

Repo Wiki 会为你的项目自动生成结构化文档，并持续跟踪代码与文档的变更。

当你在开发过程中查询知识点、代码解释、增加功能特性时，Repo Wiki 会深入分析项目结构和代码实现，结合Repo Wiki 与上下文信息，给出更准确、详细的解答和文档支持，并且让智能体具备更深入代码库认知。

### Wiki 生成

仓库中的 Wiki 不是静态的——它会与代码保持同步。

Wiki 会在三种关键情况下更新。了解它们的触发时机与原因，有助于你保持 Wiki 的实时更新。

#### 初次生成 Wiki

当你首次打开项目时，默认不存在 Wiki。你可以一键从零生成。

#### 检测到代码变更

初次生成后，系统会持续监控代码的变更。

如果你修改了已被 Wiki 记录的内容（例如函数签名、类定义、API 端点），系统会检测到当前代码与现有 Wiki 的不一致。你可以点击 更新 仅重新生成受影响的部分。

请将代码变更控制在 10,000 行以内，以避免 Wiki 生成错误。

#### Git 目录同步

仅适用于 0.2.0 及更高版本。

如果你直接在 Git 目录中编辑 Markdown 文件，系统会检测到 Git 内容与 Wiki 不一致。你可以点击 同步 将 Git 中的变更同步并更新 Wiki。

### 限制

- 每个项目最多 10,000 个文件
  如果项目包含超过 10,000 个文件，建议在 Qoder 设置 → 代码库索引 → 索引排除 中排除非必要路径。
- 仅支持 Git 仓库且至少包含一次提交

### Wiki 共享

仅适用于 0.2.0 及更高版本。

我们支持 Wiki 共享，助力团队内的知识更高效流动。

当你在本地生成 Wiki 时，系统会在代码仓库中自动创建一个专用目录：.qoder/repowiki。

你可以将该目录提交并推送到远程分支。团队成员随后可通过 git pull 拉取生成的 Wiki 内容——无需额外配置。

### 多语言支持

仅适用于 0.2.0 及更高版本。

Wiki 系统支持多语言——你可以在生成 Wiki 时选择首选语言。目前支持 English 和 中文。

在生成 Wiki 时，系统会根据你的语言选择，在 Git 目录下为每种选定的语言自动创建独立目录（例如 repowiki/zh/、repowiki/en/）。

### 使用场景

#### 架构与实现相关查询

智能体凭借预构建的架构知识，几乎无需调用工具，即可快速解答诸如"X 是如何实现的？"或"哪些服务依赖此模块？"之类的问题。

#### 智能体驱动的开发任务

在上下文宽度受限时，Repo Wiki 可加速代码定位，支持以下任务：

- 添加新功能
- 修复漏洞

## 上下文

Qoder 支持丰富的上下文输入，例如代码文件、目录、图像、git 提交（gitCommit）以及规则。你可以借助这些资源来补充提问，从而更清晰地表达你的需求。

### 如何添加上下文

使用以下任一方式打开 context 选择窗口，在智能会话中添加上下文：

1. **方法一**：点击输入框中的 + 添加上下文。
2. **方法二**：在输入框中输入 @，继续输入以搜索文件。选择一种上下文类型，例如 @file、@folder 或 @gitCommit，然后搜索特定内容。支持多选。
3. **方法三**：拖放或复制粘贴代码文件和图片，将其添加为上下文。

### 支持的上下文类型

Qoder 提供多种上下文选项，可与您的输入搭配使用，用于构建完整的需求描述。

支持的上下文类型如下：

- @file
- @rule
- @folder
- @image
- @codeChanges
- @gitCommit

以下是这些上下文类型的详细说明。

### @file

使用此命令就一个或多个文件提问，或对其进行修改。

在输入框中键入 @file 以选择一个或多个代码文件。

你也可以将文件从资源管理器拖到聊天框中，将其作为上下文添加。

**添加文件时的几点提示**：

- 如需在描述中强调某个文件，输入 @ 后接文件名。
- 通过拖放将文件作为上下文添加时，会自动获得强调。

### @rule

将规则嵌入到每次模型调用的系统提示中，提供持久、可复用的上下文，从而在代码生成、重构和工作流自动化中保持一致性的指导。

### @folder

使用此命令查询或修改代码片段。在搜索、重构、添加注释或生成单元测试时非常有用。

输入 @folder，按名称搜索文件夹。选择包含该代码片段的项目文件夹，并附上你的需求。

### @image

使用此命令添加图片，并生成代码、修复缺陷或直观展示内容。例如，你可以根据设计稿生成一个前端页面。

输入 @image，Qoder 会提示你上传图片。你也可以将图片直接复制并粘贴到聊天框中。

### @codeChanges

要查看当前 Git 暂存区中的代码变更，请使用@codeChanges命令。例如，在将代码推送到 Git 仓库之前，你可以让 Qoder 审查并优化代码，或补充单元测试。

### @gitCommit

对于 Git 提交中的代码更改，使用 @gitCommit 添加提交详情。比如，可选择一条或多条 Git 提交记录，用于故障排查、缺陷修复和单元测试生成等任务。

## 索引

当你打开项目时，Qoder 会自动为代码库建立索引，方法是生成文件嵌入向量。这使基于 AI 的代码理解、智能推荐和语义搜索成为可能。索引以增量方式进行，因此新建或已修改的文件会实时处理——无需人工干预。

### 配置索引

在 Qoder IDE 右上角，点击用户图标，或使用键盘快捷键（⌘ ⇧ ,（macOS）或 Ctrl Shift ,（Windows）），然后选择 Qoder 设置。

在左侧导航栏中，点击 代码库索引。

选择以下之一：

- 若要手动启用索引，点击 代码库索引 旁的 创建。
- 若要启用持续的后台索引，将 自动更新 切换为开启。

**注意**： 支持最多 100,000 个文件的代码库。对于少于 10,000 个文件的代码库，自动更新默认开启。对于更大的代码库，需要手动启用索引。

### 忽略文件

默认情况下，Qoder 会为所有项目文件建立索引，但以下情况除外：

- .gitignore 中指定的文件和目录
- .qoderignore 中列出的文件

### 指定自定义忽略文件

你可以定义额外需要从索引中排除的文件或目录。

在 Qoder IDE 的右上角，点击用户图标，或使用键盘快捷键（⌘ ⇧ ,（macOS）或 Ctrl Shift ,（Windows）），然后选择 Qoder 设置。

在左侧导航栏，点击 代码库索引。

在 忽略文件 旁点击 管理。

添加自定义匹配模式。

#### 模式示例

| 格式 | 描述 |
| --- | --- |
| config.json | 忽略特定文件 |
| dist/ | 忽略整个目录 |
| *.log | 忽略所有 .log 扩展名的文件 |
| **/logs | 忽略任意嵌套层级中的 logs 目录 |
| !app/ | 从忽略规则中排除某个路径（取反） |

要检查某个特定文件是否被忽略，请使用以下命令：

```bash
git check-ignore -v [file]
```

### 常见问题解答

#### 我可以在哪里查看已建立索引的代码库？

目前没有集中式的索引列表。你可以在各项目的索引设置中查看已建立索引的代码库。

#### 我的源代码会存放在 Qoder 的服务器上吗？

不会。Qoder 不会存储你的源代码。

## 记忆

Qoder 提供长期记忆功能。随着开发者与 Qoder 互动，它会逐步构建一套全面的记忆库，涵盖个人开发者、特定项目以及遇到的问题等信息。这些记忆会随时间自动整理并更新。

借助这一能力，Qoder 能更高效地与开发者协作，并在长期使用中更深入地理解每位开发者的独特需求与上下文。

**注意**： 当 规则 与记忆发生冲突时，以 规则 为准。

### 主动记忆

在智能会话面板切换到智能体模式，输入你希望 Qoder 记住的内容。Qoder 会保存这些信息。稍后你可以在智能会话面板中询问以检索这些信息。

### 自动记忆

Qoder 会自动保留对话，并随时间推移学习你的编码风格和项目细节。

### 查看记忆

在 Qoder IDE 的右上角，点击用户图标，或使用键盘快捷键（⌘ ⇧ ,（macOS）或 Ctrl Shift ,（Windows）），然后选择 Qoder 设置。接着，点击 记忆 查看已保存的记忆。你可以移除不需要的条目。

### 记忆范围

当开发者在项目中工作时，既有反映个人偏好的全局记忆，也有项目特定记忆会被激活，并在与 Qoder 的所有交互中生效。

## 规则

Qoder 支持为每个项目配置专属规则。规则存放于 .qoder/rules 目录中，仅对当前项目生效。它们可优化模型对你的编码偏好的适配，包括项目所用框架与代码风格。

### 规则如何工作

大型语言模型（LLMs）依赖通用知识，因此缺乏你项目特定的上下文和规则。Qoder 的规则通过将预定义的上下文有策略地注入到提示中来弥补这一不足，从而引导 AI 的回答更一致地符合你项目的标准和要求。

### 存储与共享

规则文件直接存放在项目目录中，并通过 Git 等版本控制系统与团队成员共享，与代码库一同管理。

对于仅本地使用（不共享）的规则，请将 .qoder/rules 目录添加到项目的 .gitignore 文件中。

### 限制

- 所有活跃规则文件合计最多允许 100,000 个字符（超出部分将被截断）。
- 仅支持自然语言，不支持图片或链接。

### 规则类型

| 类型 | 描述 | 使用场景 |
| --- | --- | --- |
| 手动引入 | 通过智能会话面板或行间会话使用 @rule 手动应用。 | 按需工作流，自定义提示词 |
| 模型决策 | 模型在智能体模式下评估规则描述并决定何时应用。 | 场景化任务（例如生成单元测试或代码注释） |
| 始终生效 | 适用于所有智能会话和行间会话请求。 | 强制执行项目级标准（例如编码风格或文档格式） |
| 指定文件生效 | 适用于匹配通配符模式的所有文件（例如 .js 或 src/**/.ts）。 | 语言或目录特定的规则 |

### 最佳实践

- **保持简洁**：让规则聚焦且明确无歧义。
- **结构清晰**：使用项目符号、编号列表或 Markdown 格式以提升可读性。
- **包含示例**：提供"良好"的代码示例以指导模型。
- **迭代与优化**：根据模型输出和反馈不断完善规则。

### 配置规则

在 Qoder IDE 右上角，点击用户图标或使用键盘快捷键（⌘ ⇧ ,（macOS）或 Ctrl Shift ,（Windows）），然后选择 Qoder 设置。

在左侧导航窗格中，点击 规则。

点击 添加。

在顶部搜索栏中，输入唯一的规则名称并按 确认。

选择规则类型：

- 手动引入
- 模型决策：输入场景描述。
  - 示例："生成一个单元测试."
- 指定文件生效：提供以逗号分隔的文件路径通配符。
  - 示例：*.md、src/*.java。
- 始终生效

关闭窗口以保存更改。

### 后续步骤

要编辑或删除现有规则，请在 规则 页面点击相应图标。

## 工具

Qoder 提供了丰富的工具，覆盖文件搜索、文件读取、目录浏览、语义符号检索、文件编辑、错误检查和命令执行等编程场景。它还可与模型上下文协议（MCP）服务集成，使开发者能够配置更多扩展，进一步优化编码体验。

### 搜索

在智能体模式中，Qoder 使用以下工具从项目、代码文件和网页内容中检索信息：

| 范围 | 说明 |
| --- | --- |
| 代码库 | 用于探索代码库的代码搜索工具 |
| 文件 | 在项目内搜索文件。 |
| 代码 | 在项目内搜索特定代码片段。 |
| 目录 | 查看项目目录结构。 |
| Web | 在无需 API 密钥的情况下进行自由网页搜索。 |
| 网页内容 | 获取网页内容。 |

### 编辑

在智能体模式下，Qoder 使用以下工具来修改代码文件：

| 功能 | 说明 |
| --- | --- |
| 修改文件 | 修改特定代码文件。 |
| 查看文件 | 显示代码文件内容。 |

### 执行命令

在智能体模式下，Qoder 会根据先前的条件使用以下工具来编写并运行命令。

| 功能 | 说明 |
| --- | --- |
| 运行命令 | 在终端中执行命令。 |
| 获取终端输出 | 获取先前已运行命令的输出。 |

### 查找问题

在智能体模式下，Qoder 使用以下工具来定位代码问题。

| 功能 | 说明 |
| --- | --- |
| 获取代码问题 | 查找项目中的代码问题（在 问题 窗口中显示）。 |

### 更新记忆

在智能体模式下，Qoder 会使用以下工具根据你的需求更新记忆：

| 功能 | 描述 |
| --- | --- |
| 更新记忆 | 基于用户输入更新持久化记忆。 |

### MCP 工具

在智能体模式下，如果已配置 MCP 工具，Qoder 会根据描述自主调用所需的 MCP 工具。AI 在执行任何与 MCP 相关的操作前都会请求您的确认。若要跳过确认，您可以启用自动运行。

## MCP

模型上下文协议（MCP）通过与外部系统和数据源的无缝集成，扩展了 Qoder 的功能。本文介绍 MCP 的核心概念、支持的传输类型、配置步骤以及实际用例。

### 什么是 MCP？

MCP 是一种开放协议，用于标准化应用如何向大语言模型（LLM）提供 context 和工具。通过以一致的接口暴露功能，MCP 使 LLM 能够以结构化且安全的方式与外部系统（如 API、数据库和本地工具）进行交互。

### 为什么使用 MCP

MCP 通过标准化接口使 Qoder 智能体能够连接到各类外部系统和数据源，从而增强智能体在以下方面的能力：

- 获取实时信息
- 在外部系统中执行操作
- 处理结构化或非结构化数据

它支持个性化工作流，帮助开发者构建更智能、具备上下文感知能力的 AI 助手。

### 工作原理

MCP 服务通过 MCP 协议公开其能力（例如函数和数据访问）。Qoder 会基于用户输入和工具元数据发现并调用这些能力。

Qoder 支持两种标准传输方式：

#### 标准输入/输出（STDIO）

通过 stdin/stdout 流进行通信。

- 适用于本地工具和命令行集成。
- 需要本地环境配置——最适合专业开发者。

#### 服务发送事件（SSE）

客户端到服务使用 HTTP POST 发起请求，服务到客户端通过事件流返回响应。

- 远程托管——易于配置与使用。
- 强烈推荐给初学者和快速原型制作。

### 限制

- MCP（Model Context Protocol）服务仅在 智能体模式下受支持。
- 最多可同时使用 10 个 MCP 服务。

### 配置 MCP 服务

在 Qoder IDE 的右上角，点击用户图标，或使用键盘快捷键（⌘ ⇧ ,（macOS）或 Ctrl Shift ,（Windows）），然后选择 Qoder 设置。

在左侧导航窗格中，点击 MCP。

选择以下任一方式：

#### 连接到你自己的 MCP 服务

a. 在 我的服务 选项卡中，点击右上角的 + 添加。

b. 在弹出的 JSON 文件中，添加你的服务配置信息：

- Name
- 传输类型（STDIO 或 SSE）
- 命令和参数（用于 STDIO）
- 端点 URL（用于 SSE）

示例：

```
{
 "mcpServers": {
 "github": {
 "command": "npx",
 "args": [
 "-y",
 "@modelcontextprotocol/server-github"
 ],
 "env": {
 "GITHUB_PERSONAL_ACCESS_TOKEN": "<YOUR_TOKEN>"
 }
 }
 }
}
```

c. 关闭文件，并在提示时点击 保存。

保存后，新服务会出现在你的列表中。链接图标表示连接成功。展开该条目以查看可用工具。

#### 在 MCP 广场 中使用 MCP 服务

a. 点击 MCP 广场 选项卡。

b. 浏览可用服务列表，在目标服务上点击 安装。

**注意**： 某些 MCP 服务需要额外的环境变量（如 API_KEY 或 ACCESS_TOKEN）才能运行。这些需要手动配置。

c. 前往 我的服务 选项卡以确认安装。展开详情以查看工具列表。

**注意**： 如果服务因缺少依赖而启动失败，点击一键修复。若问题仍然存在，请手动安装依赖。有关故障排查，请参阅 MCP 常见问题。

### 使用 MCP 工具

Qoder 会根据以下内容自动选择合适的 MCP 工具：

- 你的输入提示
- 工具的名称和描述

在 Qoder 调用 MCP 工具之前，会先请求你确认。若要自动运行后续的所有 MCP 服务，请勾选此确认。随后，智能体会基于该工具的输出继续执行工作流的下一步。

#### 步骤 

1. 在智能会话面板中，切换到智能体模式并输入你的请求。
2. 调用工具前，Qoder 会先请求确认。按 ⌘ ⏎（macOS）或 Ctrl Enter（Windows）执行。
3. 执行后，结果会显示在聊天中。
4. 展开响应以查看详细的输入与输出。
5. 查看生成的代码，并按需接受更改。